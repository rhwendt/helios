// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v3.21.12
// source: proto/flow.proto

package proto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type EnrichedFlow_FlowType int32

const (
	EnrichedFlow_UNKNOWN    EnrichedFlow_FlowType = 0
	EnrichedFlow_NETFLOW_V5 EnrichedFlow_FlowType = 1
	EnrichedFlow_NETFLOW_V9 EnrichedFlow_FlowType = 2
	EnrichedFlow_IPFIX      EnrichedFlow_FlowType = 3
	EnrichedFlow_SFLOW      EnrichedFlow_FlowType = 4
)

// Enum value maps for EnrichedFlow_FlowType.
var (
	EnrichedFlow_FlowType_name = map[int32]string{
		0: "UNKNOWN",
		1: "NETFLOW_V5",
		2: "NETFLOW_V9",
		3: "IPFIX",
		4: "SFLOW",
	}
	EnrichedFlow_FlowType_value = map[string]int32{
		"UNKNOWN":    0,
		"NETFLOW_V5": 1,
		"NETFLOW_V9": 2,
		"IPFIX":      3,
		"SFLOW":      4,
	}
)

func (x EnrichedFlow_FlowType) Enum() *EnrichedFlow_FlowType {
	p := new(EnrichedFlow_FlowType)
	*p = x
	return p
}

func (x EnrichedFlow_FlowType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EnrichedFlow_FlowType) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_flow_proto_enumTypes[0].Descriptor()
}

func (EnrichedFlow_FlowType) Type() protoreflect.EnumType {
	return &file_proto_flow_proto_enumTypes[0]
}

func (x EnrichedFlow_FlowType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EnrichedFlow_FlowType.Descriptor instead.
func (EnrichedFlow_FlowType) EnumDescriptor() ([]byte, []int) {
	return file_proto_flow_proto_rawDescGZIP(), []int{0, 0}
}

// Direction
type EnrichedFlow_Direction int32

const (
	EnrichedFlow_UNKNOWN_DIR EnrichedFlow_Direction = 0
	EnrichedFlow_INGRESS     EnrichedFlow_Direction = 1
	EnrichedFlow_EGRESS      EnrichedFlow_Direction = 2
)

// Enum value maps for EnrichedFlow_Direction.
var (
	EnrichedFlow_Direction_name = map[int32]string{
		0: "UNKNOWN_DIR",
		1: "INGRESS",
		2: "EGRESS",
	}
	EnrichedFlow_Direction_value = map[string]int32{
		"UNKNOWN_DIR": 0,
		"INGRESS":     1,
		"EGRESS":      2,
	}
)

func (x EnrichedFlow_Direction) Enum() *EnrichedFlow_Direction {
	p := new(EnrichedFlow_Direction)
	*p = x
	return p
}

func (x EnrichedFlow_Direction) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EnrichedFlow_Direction) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_flow_proto_enumTypes[1].Descriptor()
}

func (EnrichedFlow_Direction) Type() protoreflect.EnumType {
	return &file_proto_flow_proto_enumTypes[1]
}

func (x EnrichedFlow_Direction) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EnrichedFlow_Direction.Descriptor instead.
func (EnrichedFlow_Direction) EnumDescriptor() ([]byte, []int) {
	return file_proto_flow_proto_rawDescGZIP(), []int{0, 1}
}

// EnrichedFlow represents a network flow record after enrichment with
// NetBox device metadata and MaxMind GeoIP data. This is the canonical
// format consumed by ClickHouse via the Kafka engine table.
type EnrichedFlow struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Timestamp in milliseconds since Unix epoch
	TimestampMs int64                 `protobuf:"varint,1,opt,name=timestamp_ms,json=timestampMs,proto3" json:"timestamp_ms,omitempty"`
	FlowType    EnrichedFlow_FlowType `protobuf:"varint,2,opt,name=flow_type,json=flowType,proto3,enum=helios.flows.EnrichedFlow_FlowType" json:"flow_type,omitempty"`
	// Exporter identity (from NetBox enrichment)
	ExporterIp     uint32 `protobuf:"fixed32,3,opt,name=exporter_ip,json=exporterIp,proto3" json:"exporter_ip,omitempty"`
	ExporterName   string `protobuf:"bytes,4,opt,name=exporter_name,json=exporterName,proto3" json:"exporter_name,omitempty"`
	ExporterSite   string `protobuf:"bytes,5,opt,name=exporter_site,json=exporterSite,proto3" json:"exporter_site,omitempty"`
	ExporterRegion string `protobuf:"bytes,6,opt,name=exporter_region,json=exporterRegion,proto3" json:"exporter_region,omitempty"`
	ExporterRole   string `protobuf:"bytes,7,opt,name=exporter_role,json=exporterRole,proto3" json:"exporter_role,omitempty"`
	// Interface information (from NetBox enrichment)
	InIf       uint32 `protobuf:"varint,10,opt,name=in_if,json=inIf,proto3" json:"in_if,omitempty"`
	OutIf      uint32 `protobuf:"varint,11,opt,name=out_if,json=outIf,proto3" json:"out_if,omitempty"`
	InIfName   string `protobuf:"bytes,12,opt,name=in_if_name,json=inIfName,proto3" json:"in_if_name,omitempty"`
	OutIfName  string `protobuf:"bytes,13,opt,name=out_if_name,json=outIfName,proto3" json:"out_if_name,omitempty"`
	InIfSpeed  uint64 `protobuf:"varint,14,opt,name=in_if_speed,json=inIfSpeed,proto3" json:"in_if_speed,omitempty"`
	OutIfSpeed uint64 `protobuf:"varint,15,opt,name=out_if_speed,json=outIfSpeed,proto3" json:"out_if_speed,omitempty"`
	// Layer 3
	SrcIp     []byte `protobuf:"bytes,20,opt,name=src_ip,json=srcIp,proto3" json:"src_ip,omitempty"` // 4 bytes (IPv4) or 16 bytes (IPv6)
	DstIp     []byte `protobuf:"bytes,21,opt,name=dst_ip,json=dstIp,proto3" json:"dst_ip,omitempty"`
	IpVersion uint32 `protobuf:"varint,22,opt,name=ip_version,json=ipVersion,proto3" json:"ip_version,omitempty"`
	Protocol  uint32 `protobuf:"varint,23,opt,name=protocol,proto3" json:"protocol,omitempty"`
	Tos       uint32 `protobuf:"varint,24,opt,name=tos,proto3" json:"tos,omitempty"`
	Ttl       uint32 `protobuf:"varint,25,opt,name=ttl,proto3" json:"ttl,omitempty"`
	// Layer 4
	SrcPort  uint32 `protobuf:"varint,30,opt,name=src_port,json=srcPort,proto3" json:"src_port,omitempty"`
	DstPort  uint32 `protobuf:"varint,31,opt,name=dst_port,json=dstPort,proto3" json:"dst_port,omitempty"`
	TcpFlags uint32 `protobuf:"varint,32,opt,name=tcp_flags,json=tcpFlags,proto3" json:"tcp_flags,omitempty"`
	IcmpType uint32 `protobuf:"varint,33,opt,name=icmp_type,json=icmpType,proto3" json:"icmp_type,omitempty"`
	IcmpCode uint32 `protobuf:"varint,34,opt,name=icmp_code,json=icmpCode,proto3" json:"icmp_code,omitempty"`
	// Counters
	Bytes        uint64 `protobuf:"varint,40,opt,name=bytes,proto3" json:"bytes,omitempty"`
	Packets      uint64 `protobuf:"varint,41,opt,name=packets,proto3" json:"packets,omitempty"`
	SamplingRate uint32 `protobuf:"varint,42,opt,name=sampling_rate,json=samplingRate,proto3" json:"sampling_rate,omitempty"`
	// Flow timing
	FlowStartMs int64 `protobuf:"varint,43,opt,name=flow_start_ms,json=flowStartMs,proto3" json:"flow_start_ms,omitempty"`
	FlowEndMs   int64 `protobuf:"varint,44,opt,name=flow_end_ms,json=flowEndMs,proto3" json:"flow_end_ms,omitempty"`
	// BGP / Routing
	SrcAs   uint32 `protobuf:"varint,50,opt,name=src_as,json=srcAs,proto3" json:"src_as,omitempty"`
	DstAs   uint32 `protobuf:"varint,51,opt,name=dst_as,json=dstAs,proto3" json:"dst_as,omitempty"`
	NextHop uint32 `protobuf:"fixed32,52,opt,name=next_hop,json=nextHop,proto3" json:"next_hop,omitempty"`
	SrcMask uint32 `protobuf:"varint,53,opt,name=src_mask,json=srcMask,proto3" json:"src_mask,omitempty"`
	DstMask uint32 `protobuf:"varint,54,opt,name=dst_mask,json=dstMask,proto3" json:"dst_mask,omitempty"`
	// GeoIP enrichment
	SrcCountry string `protobuf:"bytes,60,opt,name=src_country,json=srcCountry,proto3" json:"src_country,omitempty"`
	SrcCity    string `protobuf:"bytes,61,opt,name=src_city,json=srcCity,proto3" json:"src_city,omitempty"`
	DstCountry string `protobuf:"bytes,62,opt,name=dst_country,json=dstCountry,proto3" json:"dst_country,omitempty"`
	DstCity    string `protobuf:"bytes,63,opt,name=dst_city,json=dstCity,proto3" json:"dst_city,omitempty"`
	// ASN enrichment
	SrcAsName string `protobuf:"bytes,70,opt,name=src_as_name,json=srcAsName,proto3" json:"src_as_name,omitempty"`
	DstAsName string `protobuf:"bytes,71,opt,name=dst_as_name,json=dstAsName,proto3" json:"dst_as_name,omitempty"`
	// VLAN
	SrcVlan       uint32                 `protobuf:"varint,80,opt,name=src_vlan,json=srcVlan,proto3" json:"src_vlan,omitempty"`
	DstVlan       uint32                 `protobuf:"varint,81,opt,name=dst_vlan,json=dstVlan,proto3" json:"dst_vlan,omitempty"`
	Direction     EnrichedFlow_Direction `protobuf:"varint,82,opt,name=direction,proto3,enum=helios.flows.EnrichedFlow_Direction" json:"direction,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnrichedFlow) Reset() {
	*x = EnrichedFlow{}
	mi := &file_proto_flow_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnrichedFlow) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnrichedFlow) ProtoMessage() {}

func (x *EnrichedFlow) ProtoReflect() protoreflect.Message {
	mi := &file_proto_flow_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnrichedFlow.ProtoReflect.Descriptor instead.
func (*EnrichedFlow) Descriptor() ([]byte, []int) {
	return file_proto_flow_proto_rawDescGZIP(), []int{0}
}

func (x *EnrichedFlow) GetTimestampMs() int64 {
	if x != nil {
		return x.TimestampMs
	}
	return 0
}

func (x *EnrichedFlow) GetFlowType() EnrichedFlow_FlowType {
	if x != nil {
		return x.FlowType
	}
	return EnrichedFlow_UNKNOWN
}

func (x *EnrichedFlow) GetExporterIp() uint32 {
	if x != nil {
		return x.ExporterIp
	}
	return 0
}

func (x *EnrichedFlow) GetExporterName() string {
	if x != nil {
		return x.ExporterName
	}
	return ""
}

func (x *EnrichedFlow) GetExporterSite() string {
	if x != nil {
		return x.ExporterSite
	}
	return ""
}

func (x *EnrichedFlow) GetExporterRegion() string {
	if x != nil {
		return x.ExporterRegion
	}
	return ""
}

func (x *EnrichedFlow) GetExporterRole() string {
	if x != nil {
		return x.ExporterRole
	}
	return ""
}

func (x *EnrichedFlow) GetInIf() uint32 {
	if x != nil {
		return x.InIf
	}
	return 0
}

func (x *EnrichedFlow) GetOutIf() uint32 {
	if x != nil {
		return x.OutIf
	}
	return 0
}

func (x *EnrichedFlow) GetInIfName() string {
	if x != nil {
		return x.InIfName
	}
	return ""
}

func (x *EnrichedFlow) GetOutIfName() string {
	if x != nil {
		return x.OutIfName
	}
	return ""
}

func (x *EnrichedFlow) GetInIfSpeed() uint64 {
	if x != nil {
		return x.InIfSpeed
	}
	return 0
}

func (x *EnrichedFlow) GetOutIfSpeed() uint64 {
	if x != nil {
		return x.OutIfSpeed
	}
	return 0
}

func (x *EnrichedFlow) GetSrcIp() []byte {
	if x != nil {
		return x.SrcIp
	}
	return nil
}

func (x *EnrichedFlow) GetDstIp() []byte {
	if x != nil {
		return x.DstIp
	}
	return nil
}

func (x *EnrichedFlow) GetIpVersion() uint32 {
	if x != nil {
		return x.IpVersion
	}
	return 0
}

func (x *EnrichedFlow) GetProtocol() uint32 {
	if x != nil {
		return x.Protocol
	}
	return 0
}

func (x *EnrichedFlow) GetTos() uint32 {
	if x != nil {
		return x.Tos
	}
	return 0
}

func (x *EnrichedFlow) GetTtl() uint32 {
	if x != nil {
		return x.Ttl
	}
	return 0
}

func (x *EnrichedFlow) GetSrcPort() uint32 {
	if x != nil {
		return x.SrcPort
	}
	return 0
}

func (x *EnrichedFlow) GetDstPort() uint32 {
	if x != nil {
		return x.DstPort
	}
	return 0
}

func (x *EnrichedFlow) GetTcpFlags() uint32 {
	if x != nil {
		return x.TcpFlags
	}
	return 0
}

func (x *EnrichedFlow) GetIcmpType() uint32 {
	if x != nil {
		return x.IcmpType
	}
	return 0
}

func (x *EnrichedFlow) GetIcmpCode() uint32 {
	if x != nil {
		return x.IcmpCode
	}
	return 0
}

func (x *EnrichedFlow) GetBytes() uint64 {
	if x != nil {
		return x.Bytes
	}
	return 0
}

func (x *EnrichedFlow) GetPackets() uint64 {
	if x != nil {
		return x.Packets
	}
	return 0
}

func (x *EnrichedFlow) GetSamplingRate() uint32 {
	if x != nil {
		return x.SamplingRate
	}
	return 0
}

func (x *EnrichedFlow) GetFlowStartMs() int64 {
	if x != nil {
		return x.FlowStartMs
	}
	return 0
}

func (x *EnrichedFlow) GetFlowEndMs() int64 {
	if x != nil {
		return x.FlowEndMs
	}
	return 0
}

func (x *EnrichedFlow) GetSrcAs() uint32 {
	if x != nil {
		return x.SrcAs
	}
	return 0
}

func (x *EnrichedFlow) GetDstAs() uint32 {
	if x != nil {
		return x.DstAs
	}
	return 0
}

func (x *EnrichedFlow) GetNextHop() uint32 {
	if x != nil {
		return x.NextHop
	}
	return 0
}

func (x *EnrichedFlow) GetSrcMask() uint32 {
	if x != nil {
		return x.SrcMask
	}
	return 0
}

func (x *EnrichedFlow) GetDstMask() uint32 {
	if x != nil {
		return x.DstMask
	}
	return 0
}

func (x *EnrichedFlow) GetSrcCountry() string {
	if x != nil {
		return x.SrcCountry
	}
	return ""
}

func (x *EnrichedFlow) GetSrcCity() string {
	if x != nil {
		return x.SrcCity
	}
	return ""
}

func (x *EnrichedFlow) GetDstCountry() string {
	if x != nil {
		return x.DstCountry
	}
	return ""
}

func (x *EnrichedFlow) GetDstCity() string {
	if x != nil {
		return x.DstCity
	}
	return ""
}

func (x *EnrichedFlow) GetSrcAsName() string {
	if x != nil {
		return x.SrcAsName
	}
	return ""
}

func (x *EnrichedFlow) GetDstAsName() string {
	if x != nil {
		return x.DstAsName
	}
	return ""
}

func (x *EnrichedFlow) GetSrcVlan() uint32 {
	if x != nil {
		return x.SrcVlan
	}
	return 0
}

func (x *EnrichedFlow) GetDstVlan() uint32 {
	if x != nil {
		return x.DstVlan
	}
	return 0
}

func (x *EnrichedFlow) GetDirection() EnrichedFlow_Direction {
	if x != nil {
		return x.Direction
	}
	return EnrichedFlow_UNKNOWN_DIR
}

var File_proto_flow_proto protoreflect.FileDescriptor

const file_proto_flow_proto_rawDesc = "" +
	"\n" +
	"\x10proto/flow.proto\x12\fhelios.flows\"\xc2\v\n" +
	"\fEnrichedFlow\x12!\n" +
	"\ftimestamp_ms\x18\x01 \x01(\x03R\vtimestampMs\x12@\n" +
	"\tflow_type\x18\x02 \x01(\x0e2#.helios.flows.EnrichedFlow.FlowTypeR\bflowType\x12\x1f\n" +
	"\vexporter_ip\x18\x03 \x01(\aR\n" +
	"exporterIp\x12#\n" +
	"\rexporter_name\x18\x04 \x01(\tR\fexporterName\x12#\n" +
	"\rexporter_site\x18\x05 \x01(\tR\fexporterSite\x12'\n" +
	"\x0fexporter_region\x18\x06 \x01(\tR\x0eexporterRegion\x12#\n" +
	"\rexporter_role\x18\a \x01(\tR\fexporterRole\x12\x13\n" +
	"\x05in_if\x18\n" +
	" \x01(\rR\x04inIf\x12\x15\n" +
	"\x06out_if\x18\v \x01(\rR\x05outIf\x12\x1c\n" +
	"\n" +
	"in_if_name\x18\f \x01(\tR\binIfName\x12\x1e\n" +
	"\vout_if_name\x18\r \x01(\tR\toutIfName\x12\x1e\n" +
	"\vin_if_speed\x18\x0e \x01(\x04R\tinIfSpeed\x12 \n" +
	"\fout_if_speed\x18\x0f \x01(\x04R\n" +
	"outIfSpeed\x12\x15\n" +
	"\x06src_ip\x18\x14 \x01(\fR\x05srcIp\x12\x15\n" +
	"\x06dst_ip\x18\x15 \x01(\fR\x05dstIp\x12\x1d\n" +
	"\n" +
	"ip_version\x18\x16 \x01(\rR\tipVersion\x12\x1a\n" +
	"\bprotocol\x18\x17 \x01(\rR\bprotocol\x12\x10\n" +
	"\x03tos\x18\x18 \x01(\rR\x03tos\x12\x10\n" +
	"\x03ttl\x18\x19 \x01(\rR\x03ttl\x12\x19\n" +
	"\bsrc_port\x18\x1e \x01(\rR\asrcPort\x12\x19\n" +
	"\bdst_port\x18\x1f \x01(\rR\adstPort\x12\x1b\n" +
	"\ttcp_flags\x18  \x01(\rR\btcpFlags\x12\x1b\n" +
	"\ticmp_type\x18! \x01(\rR\bicmpType\x12\x1b\n" +
	"\ticmp_code\x18\" \x01(\rR\bicmpCode\x12\x14\n" +
	"\x05bytes\x18( \x01(\x04R\x05bytes\x12\x18\n" +
	"\apackets\x18) \x01(\x04R\apackets\x12#\n" +
	"\rsampling_rate\x18* \x01(\rR\fsamplingRate\x12\"\n" +
	"\rflow_start_ms\x18+ \x01(\x03R\vflowStartMs\x12\x1e\n" +
	"\vflow_end_ms\x18, \x01(\x03R\tflowEndMs\x12\x15\n" +
	"\x06src_as\x182 \x01(\rR\x05srcAs\x12\x15\n" +
	"\x06dst_as\x183 \x01(\rR\x05dstAs\x12\x19\n" +
	"\bnext_hop\x184 \x01(\aR\anextHop\x12\x19\n" +
	"\bsrc_mask\x185 \x01(\rR\asrcMask\x12\x19\n" +
	"\bdst_mask\x186 \x01(\rR\adstMask\x12\x1f\n" +
	"\vsrc_country\x18< \x01(\tR\n" +
	"srcCountry\x12\x19\n" +
	"\bsrc_city\x18= \x01(\tR\asrcCity\x12\x1f\n" +
	"\vdst_country\x18> \x01(\tR\n" +
	"dstCountry\x12\x19\n" +
	"\bdst_city\x18? \x01(\tR\adstCity\x12\x1e\n" +
	"\vsrc_as_name\x18F \x01(\tR\tsrcAsName\x12\x1e\n" +
	"\vdst_as_name\x18G \x01(\tR\tdstAsName\x12\x19\n" +
	"\bsrc_vlan\x18P \x01(\rR\asrcVlan\x12\x19\n" +
	"\bdst_vlan\x18Q \x01(\rR\adstVlan\x12B\n" +
	"\tdirection\x18R \x01(\x0e2$.helios.flows.EnrichedFlow.DirectionR\tdirection\"M\n" +
	"\bFlowType\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\x0e\n" +
	"\n" +
	"NETFLOW_V5\x10\x01\x12\x0e\n" +
	"\n" +
	"NETFLOW_V9\x10\x02\x12\t\n" +
	"\x05IPFIX\x10\x03\x12\t\n" +
	"\x05SFLOW\x10\x04\"5\n" +
	"\tDirection\x12\x0f\n" +
	"\vUNKNOWN_DIR\x10\x00\x12\v\n" +
	"\aINGRESS\x10\x01\x12\n" +
	"\n" +
	"\x06EGRESS\x10\x02BAZ?github.com/rhwendt/helios/services/flow-enricher/internal/protob\x06proto3"

var (
	file_proto_flow_proto_rawDescOnce sync.Once
	file_proto_flow_proto_rawDescData []byte
)

func file_proto_flow_proto_rawDescGZIP() []byte {
	file_proto_flow_proto_rawDescOnce.Do(func() {
		file_proto_flow_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_flow_proto_rawDesc), len(file_proto_flow_proto_rawDesc)))
	})
	return file_proto_flow_proto_rawDescData
}

var file_proto_flow_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_proto_flow_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_proto_flow_proto_goTypes = []any{
	(EnrichedFlow_FlowType)(0),  // 0: helios.flows.EnrichedFlow.FlowType
	(EnrichedFlow_Direction)(0), // 1: helios.flows.EnrichedFlow.Direction
	(*EnrichedFlow)(nil),        // 2: helios.flows.EnrichedFlow
}
var file_proto_flow_proto_depIdxs = []int32{
	0, // 0: helios.flows.EnrichedFlow.flow_type:type_name -> helios.flows.EnrichedFlow.FlowType
	1, // 1: helios.flows.EnrichedFlow.direction:type_name -> helios.flows.EnrichedFlow.Direction
	2, // [2:2] is the sub-list for method output_type
	2, // [2:2] is the sub-list for method input_type
	2, // [2:2] is the sub-list for extension type_name
	2, // [2:2] is the sub-list for extension extendee
	0, // [0:2] is the sub-list for field type_name
}

func init() { file_proto_flow_proto_init() }
func file_proto_flow_proto_init() {
	if File_proto_flow_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_flow_proto_rawDesc), len(file_proto_flow_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   1,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_proto_flow_proto_goTypes,
		DependencyIndexes: file_proto_flow_proto_depIdxs,
		EnumInfos:         file_proto_flow_proto_enumTypes,
		MessageInfos:      file_proto_flow_proto_msgTypes,
	}.Build()
	File_proto_flow_proto = out.File
	file_proto_flow_proto_goTypes = nil
	file_proto_flow_proto_depIdxs = nil
}
